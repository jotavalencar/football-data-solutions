# -*- coding: utf-8 -*-
"""Estatistica v1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IHtswTCYg8SZry9nsIzxwc1EFsqojeCt

Cotovelo
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import numpy as np

# Montar o Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Especifique o caminho completo para o seu arquivo no Google Drive
file_path = '/content/drive/MyDrive/Futebol/Dados/Fut 1.2 - Quintil.xlsx'

# Lista de posições e suas respectivas colunas
posicoes = {
    'Goleiros': ['goals.conceded', 'goals.saves', 'passes.on', 'duels.won', 'penalty.saved'],
    'Zagueiros': ['passes.on', 'tackles', 'blocks', 'interceptions', 'duels.won', 'duels.total'],
    'Laterais': ['passes.key', 'passes.on', 'tackles', 'blocks', 'interceptions', 'duels.won', 'dribbles.success'],
    'Volantes': ['passes.key', 'passes.on', 'tackles', 'blocks', 'interceptions', 'duels.won', 'dribbles.success'],
    'Meio Ofensivos': ['shots.on', 'goals.total', 'goals.assists', 'passes.key', 'passes.on', 'tackles', 'interceptions', 'duels.won', 'dribbles.success', 'fouls.drawn'],
    'Pontas': ['shots.on', 'goals.total', 'goals.assists', 'passes.key', 'passes.on', 'tackles', 'interceptions', 'duels.won', 'dribbles.success', 'fouls.drawn'],
    'Atacantes': ['shots.on', 'goals.total', 'goals.assists', 'passes.key', 'passes.on', 'tackles', 'interceptions', 'duels.won', 'dribbles.success']
}

# Função para calcular a quantidade ótima de clusters usando o método do cotovelo
def calcular_quantidade_otima_clusters(data):
    sse = []
    for k in range(1, 11):
        kmeans = KMeans(n_clusters=k, random_state=42)
        kmeans.fit(data)
        sse.append(kmeans.inertia_)

    # Calcular a diferença entre os valores SSE
    diff = np.diff(sse)

    # Encontrar o ponto de "cotovelo" onde a diferença começa a nivelar
    for i in range(1, len(diff)):
        if diff[i] < 0.2 * diff[i - 1]:  # Ajuste o valor 0.2 conforme necessário
            quantidade_otima_clusters = i + 1  # Adicione 1 para compensar a indexação
            break
    else:
        quantidade_otima_clusters = 1

    # Plotar o gráfico do cotovelo para análise visual
    plt.figure(figsize=(8, 6))
    sns.lineplot(x=range(1, 11), y=sse, marker='o', linestyle='--')
    plt.xlabel('Número de Clusters (K)')
    plt.ylabel('SSE')
    plt.title('Método do Cotovelo')
    plt.grid(True)
    plt.show()

    return quantidade_otima_clusters

# Loop para carregar DataFrames e calcular a quantidade ótima de clusters para cada posição
for posicao, colunas in posicoes.items():
    df = pd.read_excel(file_path, sheet_name=posicao)
    df = df[colunas]

    quantidade_otima_clusters = calcular_quantidade_otima_clusters(df)
    print(f'Quantidade ótima de clusters para {posicao}: {quantidade_otima_clusters}')

"""K mean 1"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import numpy as np

# Montar o Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Especifique o caminho completo para o seu arquivo no Google Drive
file_path = '/content/drive/MyDrive/Futebol/Dados/Fut 1.2 - Quintil.xlsx'

# Lista de posições e suas respectivas colunas
posicoes = {
    'Goleiros': ['goals.conceded', 'goals.saves', 'passes.on', 'duels.won', 'penalty.saved'],
    'Zagueiros': ['passes.on', 'tackles', 'blocks', 'interceptions', 'duels.won', 'duels.total'],
    'Laterais': ['passes.key', 'passes.on', 'tackles', 'blocks', 'interceptions', 'duels.won', 'dribbles.success'],
    'Volantes': ['passes.key', 'passes.on', 'tackles', 'blocks', 'interceptions', 'duels.won', 'dribbles.success'],
    'Meio Ofensivos': ['shots.on', 'goals.total', 'goals.assists', 'passes.key', 'passes.on', 'tackles', 'interceptions', 'duels.won', 'dribbles.success', 'fouls.drawn'],
    'Pontas': ['shots.on', 'goals.total', 'goals.assists', 'passes.key', 'passes.on', 'tackles', 'interceptions', 'duels.won', 'dribbles.success', 'fouls.drawn'],
    'Atacantes': ['shots.on', 'goals.total', 'goals.assists', 'passes.key', 'passes.on', 'tackles', 'interceptions', 'duels.won', 'dribbles.success']
}

# Função para calcular a quantidade ótima de clusters usando o método do cotovelo
def calcular_quantidade_otima_clusters(data):
    sse = []
    for k in range(1, 11):
        kmeans = KMeans(n_clusters=k, random_state=42)
        kmeans.fit(data)
        sse.append(kmeans.inertia_)

    # Calcular a diferença entre os valores SSE
    diff = np.diff(sse)

    # Encontrar o ponto de "cotovelo" onde a diferença começa a nivelar
    for i in range(1, len(diff)):
        if diff[i] < 0.2 * diff[i - 1]:  # Ajuste o valor 0.2 conforme necessário
            quantidade_otima_clusters = i + 1  # Adicione 1 para compensar a indexação
            break
    else:
        quantidade_otima_clusters = 1

    # Plotar o gráfico do cotovelo para análise visual
    plt.figure(figsize=(8, 6))
    sns.lineplot(x=range(1, 11), y=sse, marker='o', linestyle='--')
    plt.xlabel('Número de Clusters (K)')
    plt.ylabel('SSE')
    plt.title('Método do Cotovelo')
    plt.grid(True)
    plt.show()

    return quantidade_otima_clusters

# Função para criar o modelo K-Means e plotar o gráfico de dispersão
def criar_kmeans(data, n_clusters, posicao):
    kmeans = KMeans(n_clusters=n_clusters, random_state=42)
    kmeans.fit(data)

    # Plotar o gráfico de dispersão
    plt.figure(figsize=(8, 6))
    sns.scatterplot(x=data.iloc[:, 0], y=data.iloc[:, 1], hue=kmeans.labels_, palette='viridis', s=100)
    plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], c='red', marker='x', s=200, label='Centroids')
    plt.xlabel('Feature 1')
    plt.ylabel('Feature 2')
    plt.title(f'K-Means Clustering para {posicao}')
    plt.legend()
    plt.grid(True)
    plt.show()

# Loop para carregar DataFrames, calcular a quantidade ótima de clusters e criar o modelo K-Means para cada posição
for posicao, colunas in posicoes.items():
    df = pd.read_excel(file_path, sheet_name=posicao)
    df = df[colunas]

    quantidade_otima_clusters = calcular_quantidade_otima_clusters(df)
    print(f'Quantidade ótima de clusters para {posicao}: {quantidade_otima_clusters}')

    # Criar o modelo K-Means com a quantidade ótima de clusters
    criar_kmeans(df, quantidade_otima_clusters, posicao)

"""K mean 2"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

# Montar o Google Drive
from google.colab import drive
drive.mount('/content/drive')

# Especifique o caminho completo para o seu arquivo no Google Drive
file_path = '/content/drive/MyDrive/Futebol/Dados/Fut 1.2 - Quintil.xlsx'

# Lista de posições e suas respectivas colunas
posicoes = {
    'Goleiros': ['goals.conceded', 'goals.saves', 'passes.on', 'duels.won', 'penalty.saved'],
    'Zagueiros': ['passes.on', 'tackles', 'blocks', 'interceptions', 'duels.won', 'duels.total'],
    'Laterais': ['passes.key', 'passes.on', 'tackles', 'blocks', 'interceptions', 'duels.won', 'dribbles.success'],
    'Volantes': ['passes.key', 'passes.on', 'tackles', 'blocks', 'interceptions', 'duels.won', 'dribbles.success'],
    'Meio Ofensivos': ['shots.on', 'goals.total', 'goals.assists', 'passes.key', 'passes.on', 'tackles', 'interceptions', 'duels.won', 'dribbles.success', 'fouls.drawn'],
    'Pontas': ['shots.on', 'goals.total', 'goals.assists', 'passes.key', 'passes.on', 'tackles', 'interceptions', 'duels.won', 'dribbles.success', 'fouls.drawn'],
    'Atacantes': ['shots.on', 'goals.total', 'goals.assists', 'passes.key', 'passes.on', 'tackles', 'interceptions', 'duels.won', 'dribbles.success']
}

# Função para criar o modelo K-Means com variáveis padronizadas e plotar o gráfico de dispersão
def criar_kmeans_com_padronizacao(data, n_clusters, posicao):
    scaler = StandardScaler()
    data_std = scaler.fit_transform(data)  # Padronizar os dados

    kmeans = KMeans(n_clusters=n_clusters, random_state=42)
    kmeans.fit(data_std)

    # Plotar o gráfico de dispersão com os centroides
    plt.figure(figsize=(8, 6))
    sns.scatterplot(x=data_std[:, 0], y=data_std[:, 1], hue=kmeans.labels_, palette='viridis', s=100, legend='full')
    plt.scatter(kmeans.cluster_centers_[:, 0], kmeans.cluster_centers_[:, 1], c='red', marker='x', s=200, label='Centroids')
    plt.xlabel('Feature 1 (Padronizada)')
    plt.ylabel('Feature 2 (Padronizada)')
    plt.title(f'K-Means Clustering para {posicao} (com Padronização)')
    plt.legend(loc='upper right')
    plt.grid(True)
    plt.show()

# Loop para carregar DataFrames e criar o modelo K-Means com padronização
for posicao, colunas in posicoes.items():
    df = pd.read_excel(file_path, sheet_name=posicao)
    df = df[colunas]

    quantidade_otima_clusters = calcular_quantidade_otima_clusters(df)  # Você já possui essa informação

    # Criar o modelo K-Means com padronização
    criar_kmeans_com_padronizacao(df, quantidade_otima_clusters, posicao)